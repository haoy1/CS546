import os
import psycopg2
import psycopg2.extras
import tabulate
from H_Table import mf_structure
from dotenv import load_dotenv
import csv


# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname=" + dbname + " user=" + user + " password=" + password,
                            cursor_factory=psycopg2.extras.DictCursor)

    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    table = cur.fetchall()

    indices = {'cust': 0, 'prod': 1, 'day': 2, 'month': 3, 'year': 4, 'state': 5, 'quant': 6, 'date': 7}
    _global = []

    for row in table:
        if row[5] == 'NY' and row[6] > 100:
            group_keys = ", ".join([f"{row[indices[k]]}" for k in mf_structure['groupingAttribute']])
            if group_keys not in mf_structure['groupAggValue']:
                mf_structure['groupAggValue'][group_keys] = {}
            for selectedAttribute in mf_structure["selectedAttribute"]:
                if not selectedAttribute[0].isdigit() and selectedAttribute not in mf_structure['groupingAttribute']:
                    mf_structure['groupAggValue'][group_keys][selectedAttribute] = row[indices[selectedAttribute]]
            for f_vect in mf_structure["aggregateList"]:
                number = f_vect["number"]
                # only care about current grouping_variable, exit if it's not
                if (number != 1):
                    continue
                aggregate = f_vect["aggregate"]
                target = f_vect["target"]
                value = f_vect["value"]

                key = str(number) + "_" + aggregate + "_" + target
                targetIndex = indices[target]

                # initialize value for each aggregate of each distinct groups of grouping attributes
                if key not in mf_structure["groupAggValue"][group_keys]:
                    mf_structure["groupAggValue"][group_keys][key] = 0

                if aggregate == "count":
                    mf_structure["groupAggValue"][group_keys][key] += 1
                elif aggregate == "sum":
                    mf_structure["groupAggValue"][group_keys][key] += row[targetIndex]
                elif aggregate == "min":
                    mf_structure["groupAggValue"][group_keys][key] = min(row[targetIndex],
                                                                         mf_structure["groupAggValue"][group_keys][key])
                elif aggregate == "max":
                    mf_structure["groupAggValue"][group_keys][key] = max(row[targetIndex],
                                                                         mf_structure["groupAggValue"][group_keys][key])

                elif aggregate == "avg":
                    # need to introduce new 'sum' and 'count' keys to calculate average. Those columns can be neglected from output.
                    # TODO: should not need this step if we already have sum calculated
                    if "sum" not in mf_structure["groupAggValue"][group_keys]:
                        mf_structure["groupAggValue"][group_keys]["sum"] = 0
                    if "count" not in mf_structure["groupAggValue"][group_keys]:
                        mf_structure["groupAggValue"][group_keys]["count"] = 0

                    mf_structure["groupAggValue"][group_keys]["sum"] += row[targetIndex]
                    mf_structure["groupAggValue"][group_keys]["count"] += 1
                    mf_structure["groupAggValue"][group_keys][key] = mf_structure["groupAggValue"][group_keys]["sum"] / \
                                                                     mf_structure["groupAggValue"][group_keys]["count"]

        #output_cursor_i += 1
        #print(mf_structure["groupAggValue"])
        if row[5] == 'NJ':
            group_keys = ", ".join([f"{row[indices[k]]}" for k in mf_structure['groupingAttribute']])
            if group_keys not in mf_structure['groupAggValue']:
                mf_structure['groupAggValue'][group_keys] = {}
            for selectedAttribute in mf_structure["selectedAttribute"]:
                if not selectedAttribute[0].isdigit() and selectedAttribute not in mf_structure['groupingAttribute']:
                    mf_structure['groupAggValue'][group_keys][selectedAttribute] = row[indices[selectedAttribute]]
            for f_vect in mf_structure["aggregateList"]:
                number = f_vect["number"]
                # only care about current grouping_variable, exit if it's not
                if (number != 2):
                    continue
                aggregate = f_vect["aggregate"]
                target = f_vect["target"]
                value = f_vect["value"]

                key = str(number) + "_" + aggregate + "_" + target
                targetIndex = indices[target]

                # initialize value for each aggregate of each distinct groups of grouping attributes
                if key not in mf_structure["groupAggValue"][group_keys]:
                    mf_structure["groupAggValue"][group_keys][key] = 0

                if aggregate == "count":
                    mf_structure["groupAggValue"][group_keys][key] += 1
                elif aggregate == "sum":
                    mf_structure["groupAggValue"][group_keys][key] += row[targetIndex]
                elif aggregate == "min":
                    mf_structure["groupAggValue"][group_keys][key] = min(row[targetIndex],
                                                                         mf_structure["groupAggValue"][group_keys][key])
                elif aggregate == "max":
                    mf_structure["groupAggValue"][group_keys][key] = max(row[targetIndex],
                                                                         mf_structure["groupAggValue"][group_keys][key])

                elif aggregate == "avg":
                    # need to introduce new 'sum' and 'count' keys to calculate average. Those columns can be neglected from output.
                    # TODO: should not need this step if we already have sum calculated
                    if "sum" not in mf_structure["groupAggValue"][group_keys]:
                        mf_structure["groupAggValue"][group_keys]["sum"] = 0
                    if "count" not in mf_structure["groupAggValue"][group_keys]:
                        mf_structure["groupAggValue"][group_keys]["count"] = 0

                    mf_structure["groupAggValue"][group_keys]["sum"] += row[targetIndex]
                    mf_structure["groupAggValue"][group_keys]["count"] += 1
                    mf_structure["groupAggValue"][group_keys][key] = mf_structure["groupAggValue"][group_keys]["sum"] / \
                                                                     mf_structure["groupAggValue"][group_keys]["count"]

        #output_cursor_i += 1
        #print(mf_structure["groupAggValue"])
        if row[5] == 'CT':
            group_keys = ", ".join([f"{row[indices[k]]}" for k in mf_structure['groupingAttribute']])
            if group_keys not in mf_structure['groupAggValue']:
                mf_structure['groupAggValue'][group_keys] = {}
            for selectedAttribute in mf_structure["selectedAttribute"]:
                if not selectedAttribute[0].isdigit() and selectedAttribute not in mf_structure['groupingAttribute']:
                    mf_structure['groupAggValue'][group_keys][selectedAttribute] = row[indices[selectedAttribute]]
            for f_vect in mf_structure["aggregateList"]:
                number = f_vect["number"]
                # only care about current grouping_variable, exit if it's not
                if (number != 3):
                    continue
                aggregate = f_vect["aggregate"]
                target = f_vect["target"]
                value = f_vect["value"]

                key = str(number) + "_" + aggregate + "_" + target
                targetIndex = indices[target]

                # initialize value for each aggregate of each distinct groups of grouping attributes
                if key not in mf_structure["groupAggValue"][group_keys]:
                    mf_structure["groupAggValue"][group_keys][key] = 0

                if aggregate == "count":
                    mf_structure["groupAggValue"][group_keys][key] += 1
                elif aggregate == "sum":
                    mf_structure["groupAggValue"][group_keys][key] += row[targetIndex]
                elif aggregate == "min":
                    mf_structure["groupAggValue"][group_keys][key] = min(row[targetIndex],
                                                                         mf_structure["groupAggValue"][group_keys][key])
                elif aggregate == "max":
                    mf_structure["groupAggValue"][group_keys][key] = max(row[targetIndex],
                                                                         mf_structure["groupAggValue"][group_keys][key])

                elif aggregate == "avg":
                    # need to introduce new 'sum' and 'count' keys to calculate average. Those columns can be neglected from output.
                    # TODO: should not need this step if we already have sum calculated
                    if "sum" not in mf_structure["groupAggValue"][group_keys]:
                        mf_structure["groupAggValue"][group_keys]["sum"] = 0
                    if "count" not in mf_structure["groupAggValue"][group_keys]:
                        mf_structure["groupAggValue"][group_keys]["count"] = 0

                    mf_structure["groupAggValue"][group_keys]["sum"] += row[targetIndex]
                    mf_structure["groupAggValue"][group_keys]["count"] += 1
                    mf_structure["groupAggValue"][group_keys][key] = mf_structure["groupAggValue"][group_keys]["sum"] / \
                                                                     mf_structure["groupAggValue"][group_keys]["count"]

        #output_cursor_i += 1
        #print(mf_structure["groupAggValue"])

    for group_key in mf_structure["output"].keys():
        for f_vect in mf_structure["aggregateList"]:
            number = f_vect["number"]
            aggregate = f_vect["aggregate"]
            target = f_vect["target"]
            key = str(number) + "_" + aggregate + "_" + target
            targetIndex = indices[target]

            # initialize value for each aggregate of each distinct groups of grouping attributes
            if key not in mf_structure["output"][group_key]:
                mf_structure["output"][group_key][key] = "NULL"

    newTable = {}
    for key, row in mf_structure["output"].items():
        if (row['1_sum_quant'] > 2 * row['2_sum_quant'] or row['1_avg_quant'] > row['3_avg_quant']):
            newTable[key] = row

    output = []
    header = mf_structure['selectedAttribute']
    output.append(header)
    for group, aggregates in newTable.items():
        new_row = []
        for key in group.split(", "):
            new_row.append(key)
        for col_name in header:
            if col_name in aggregates:
                new_row.append(aggregates[col_name])
        output.append(new_row)

    # Path to the CSV file
    csv_file_path = 'new_file.csv'

    with open(csv_file_path, 'w', newline='') as csvfile:
        # Create a CSV writer object
        csv_writer = csv.writer(csvfile)

        # Write the data to the CSV file
        csv_writer.writerows(output)

    return tabulate.tabulate(_global,
                             headers="keys", tablefmt="psql")


def main():
    print(query())


if "__main__" == __name__:
    main()
