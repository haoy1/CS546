
import os
import psycopg2
import psycopg2.extras
import tabulate
from H_Table import mf_structure
import collections
from dotenv import load_dotenv
import csv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)

    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    table = cur.fetchall()

    indices = {'cust': 0, 'prod': 1, 'day': 2, 'month': 3, 'year': 4, 'state': 5, 'quant': 6, 'date': 7}
    _global = []
    
    res = set()
    for row in table:
        res.add(row[0])
    mf_structure['groupingAttribute']['cust'] = list(res)


# ------ populate mf-struct with distinct values of grouping attribute ------

    for row in table:
        if row[5] == 'NY' and row[6] > 100:    
            group_keys = ", ".join([f"{row[indices[k]]}" for k in mf_structure['groupingAttribute'].keys()])
            if group_keys not in mf_structure['groupAggValue']:
                mf_structure['groupAggValue'][group_keys] = {}

            for f_vect in mf_structure["aggregateList"]:
                number = f_vect["number"]
                # only care about current grouping_variable, exit if it's not
                if(number != 1):
                    continue
                aggregate = f_vect["aggregate"]
                target = f_vect["target"]
                value = f_vect["value"]
  
                key = str(number) + "_" + aggregate + "_" + target
                targetIndex = indices[target]
                
                # initialize value for each aggregate of each distinct groups of grouping attributes
                if key not in mf_structure["groupAggValue"][group_keys]:
                    mf_structure["groupAggValue"][group_keys][key] = 0   

                if aggregate == "count":
                        mf_structure["groupAggValue"][group_keys][key] += 1
                elif aggregate == "sum":
                        mf_structure["groupAggValue"][group_keys][key] += row[targetIndex]                       
                elif aggregate == "min":
                        mf_structure["groupAggValue"][group_keys][key] = min(row[targetIndex], mf_structure["groupAggValue"][group_keys][key])
                elif aggregate == "max":
                        mf_structure["groupAggValue"][group_keys][key] = max(row[targetIndex], mf_structure["groupAggValue"][group_keys][key])
                                    
                elif aggregate == "avg":
                        # need to introduce new 'sum' and 'count' keys to calculate average. Those columns can be neglected from output.
                        # TODO: should not need this step if we already have sum calculated
                        if "sum" not in mf_structure["groupAggValue"][group_keys]:
                            mf_structure["groupAggValue"][group_keys]["sum"] = 0
                        if "count" not in mf_structure["groupAggValue"][group_keys]:
                            mf_structure["groupAggValue"][group_keys]["count"] = 0
                        
                        mf_structure["groupAggValue"][group_keys]["sum"] += row[targetIndex]
                        mf_structure["groupAggValue"][group_keys]["count"] += 1
                        mf_structure["groupAggValue"][group_keys][key] = mf_structure["groupAggValue"][group_keys]["sum"] / mf_structure["groupAggValue"][group_keys]["count"]

        #output_cursor_i += 1
        #print(mf_structure["groupAggValue"])
        if row[5] == 'NJ':     
            group_keys = ", ".join([f"{row[indices[k]]}" for k in mf_structure['groupingAttribute'].keys()])
            if group_keys not in mf_structure['groupAggValue']:
                mf_structure['groupAggValue'][group_keys] = {}

            for f_vect in mf_structure["aggregateList"]:
                number = f_vect["number"]
                # only care about current grouping_variable, exit if it's not
                if(number != 2):
                    continue
                aggregate = f_vect["aggregate"]
                target = f_vect["target"]
                value = f_vect["value"]
  
                key = str(number) + "_" + aggregate + "_" + target
                targetIndex = indices[target]
                
                # initialize value for each aggregate of each distinct groups of grouping attributes
                if key not in mf_structure["groupAggValue"][group_keys]:
                    mf_structure["groupAggValue"][group_keys][key] = 0   

                if aggregate == "count":
                        mf_structure["groupAggValue"][group_keys][key] += 1
                elif aggregate == "sum":
                        mf_structure["groupAggValue"][group_keys][key] += row[targetIndex]                       
                elif aggregate == "min":
                        mf_structure["groupAggValue"][group_keys][key] = min(row[targetIndex], mf_structure["groupAggValue"][group_keys][key])
                elif aggregate == "max":
                        mf_structure["groupAggValue"][group_keys][key] = max(row[targetIndex], mf_structure["groupAggValue"][group_keys][key])
                                    
                elif aggregate == "avg":
                        # need to introduce new 'sum' and 'count' keys to calculate average. Those columns can be neglected from output.
                        # TODO: should not need this step if we already have sum calculated
                        if "sum" not in mf_structure["groupAggValue"][group_keys]:
                            mf_structure["groupAggValue"][group_keys]["sum"] = 0
                        if "count" not in mf_structure["groupAggValue"][group_keys]:
                            mf_structure["groupAggValue"][group_keys]["count"] = 0
                        
                        mf_structure["groupAggValue"][group_keys]["sum"] += row[targetIndex]
                        mf_structure["groupAggValue"][group_keys]["count"] += 1
                        mf_structure["groupAggValue"][group_keys][key] = mf_structure["groupAggValue"][group_keys]["sum"] / mf_structure["groupAggValue"][group_keys]["count"]

        #output_cursor_i += 1
        #print(mf_structure["groupAggValue"])
        if row[5] == 'CT':     
            group_keys = ", ".join([f"{row[indices[k]]}" for k in mf_structure['groupingAttribute'].keys()])
            if group_keys not in mf_structure['groupAggValue']:
                mf_structure['groupAggValue'][group_keys] = {}

            for f_vect in mf_structure["aggregateList"]:
                number = f_vect["number"]
                # only care about current grouping_variable, exit if it's not
                if(number != 3):
                    continue
                aggregate = f_vect["aggregate"]
                target = f_vect["target"]
                value = f_vect["value"]
  
                key = str(number) + "_" + aggregate + "_" + target
                targetIndex = indices[target]
                
                # initialize value for each aggregate of each distinct groups of grouping attributes
                if key not in mf_structure["groupAggValue"][group_keys]:
                    mf_structure["groupAggValue"][group_keys][key] = 0   

                if aggregate == "count":
                        mf_structure["groupAggValue"][group_keys][key] += 1
                elif aggregate == "sum":
                        mf_structure["groupAggValue"][group_keys][key] += row[targetIndex]                       
                elif aggregate == "min":
                        mf_structure["groupAggValue"][group_keys][key] = min(row[targetIndex], mf_structure["groupAggValue"][group_keys][key])
                elif aggregate == "max":
                        mf_structure["groupAggValue"][group_keys][key] = max(row[targetIndex], mf_structure["groupAggValue"][group_keys][key])
                                    
                elif aggregate == "avg":
                        # need to introduce new 'sum' and 'count' keys to calculate average. Those columns can be neglected from output.
                        # TODO: should not need this step if we already have sum calculated
                        if "sum" not in mf_structure["groupAggValue"][group_keys]:
                            mf_structure["groupAggValue"][group_keys]["sum"] = 0
                        if "count" not in mf_structure["groupAggValue"][group_keys]:
                            mf_structure["groupAggValue"][group_keys]["count"] = 0
                        
                        mf_structure["groupAggValue"][group_keys]["sum"] += row[targetIndex]
                        mf_structure["groupAggValue"][group_keys]["count"] += 1
                        mf_structure["groupAggValue"][group_keys][key] = mf_structure["groupAggValue"][group_keys]["sum"] / mf_structure["groupAggValue"][group_keys]["count"]

        #output_cursor_i += 1
        #print(mf_structure["groupAggValue"])
    
    output = []
    header = mf_structure['selectedAttribute']
    output.append(header)
    for group, aggregates in mf_structure["groupAggValue"].items():
        new_row = []
        for key in group.split(", "):
            new_row.append(key)
        for col_name in header:
            if col_name in aggregates:
                new_row.append(aggregates[col_name])
        output.append(new_row)

    # Path to the CSV file
    csv_file_path = 'new_file.csv'

    with open(csv_file_path, 'w', newline='') as csvfile:
        # Create a CSV writer object
        csv_writer = csv.writer(csvfile)
        
        # Write the data to the CSV file
        csv_writer.writerows(output)
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")


def main():
    print(query())


if "__main__" == __name__:
    main()
    